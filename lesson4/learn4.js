'use strict';

let obj = new Object() //Еще один способ создания объектов. Неудобный, редко
// используется, лучше через фигурные скобки

let options = { //создали объект со свойствами(ключ:значение). Если внутри
  //объекта будут функции, то они будут называться методы объекта
  width: 1024,
  hight: 1024,
  name: "test"
};

console.log(options.name); //вывыели значение ключа name в объекте opt..
options.bool = false; //создали еще одно свойство в об.
options.colours = { //создали еще одно свойство, которое тоже явл. объектом
  border: "black",
  bg: "red"
};

delete options.bool; //так удаляют свойства
console.log(options);

//так осуществляется перебор всех свойств объекта
for (let key in options) { //key - означает означает каждое свойство в options
  console.log('свойство ' + key + ' имеет значение ' + options[key]); 
} 
console.log(Object.keys(options).length); // для получения количества свойств в
//объекте. сначала говорим, что мы обращаемся ко всем ключам объекта options и
//берем их длинну - Т.е. количество

//создаем массив - частный случай объекта(структура),
// где все элементы идут по порядку 
let arr = [1, 'boat', 3, 4, 5];

arr.pop(); //метод pop удаляет последний элемент массива
arr.push("рука"); //добавляет последний элемент массива. Мы добавли 5, как строку
arr.shift(); //удаяляет первый элемент из массива
arr.unshift('мопс');

arr[99] = 99; //сотый элемент массива будет = 99
//так делать нельзя, иначек мы получим массив с кучищей пустых элементов
//это серьезная ошибка

console.log(arr.length); //возвращает не количесьво элементов массива,
//а последний элемент начиная с нулевого


for (let i = 0; i < arr.length; i++) {
  // console.log(i);
  console.log(arr[i]);  
} //при помощи такого цикла мы перебираем все элементы массива
//в квадратных скобках идет номер элемента массива, начиная с нулевого элемента
//которы равен '1' итд

arr.forEach(function (item, i, mass) { // ф-я внутри форич может принимать
  // 3 аргумента: каждый элемент в нашем массиве, номер нашего элемента,
  // сам массив. В зависимости от того, что нам нужно получить элмент. число и или
  //сам массив, то столько будет и аргум у ф-ии. например: если нужен только номер,
  //то в любом случае нужно 2 аргумента. название массива в ф-ии не должно совпадать с чем-либо
  console.log(i + ': ' + item + " (массив: " + mass + ')');
});

console.log(arr);

//Самый новый способ перебора массива. Редко встречается.
// for..of - перебирает значение именно в том элементе, который мы берем
// не работает в обхектах, только в массивах, строках и новых объектах
//из новых стандартов map, set итд
let mass = [1, 3, 4, 6, 7];

for(key in mass) {
  console.log(key);
} //т.к. в массиве ключи - это номера элементов, начиная с 0,
//то этот способ перебирает номера

for (key of mass) { //этот цикл получает значения массива
  console.log(key);
}


// // рассматриваем метод для преобразования строки,
// // где будут через запятую слова, в массив с разделителем ","
// let ans = "df,df,dsf,fgg,dfg", /* prompt("", "") */ //спрашиваем строку
//     arr = []; //задаем пустой массив

// arr = ans.split(','); //разделяем все слова из строки через зпт на эл-э массива
// console.log(arr); //вывод массива

let arr = ["sdf", 'df', 'df', 'sdf'],
    i = arr.join(', ');// метод делает из массива строку, через разделитель
    // который мы указываем в скобках

// console.log(i);

// let arr = ["sdf", '2', 'df', '1'],
//   i = arr.sort(); // метод сортирует по алфавиту, даже если будут цифры, а не
//   //по числам

let arr2 = [1,14,5],
    i = arr2.sort(compareNum);
// с помощью этого метода и заданной функции
//таким образом можно отсортировать элементы массива, если они
//числа. Используется метод быстрой сортировки, и путем вычитания двух элементов
//и получения отрицательной или положительной разницы... Треш...

function compareNum(a,b) {
  return a-b;
} 
console.log(i);


//Псевдомассив - это объект, структура которого совпадает со структурой массива
//по сути то же самое, т.е. он хранит элементы в индексах, но при этом
//псвдм не обладают методами, свойствами полноц. массивов из-за отличий в своем
// прототипе(например там нет методов join, split итд...)

//Основы ООП, раньше было функциональное программирование, везде были ф-ии,
//которые в нужный момент одна другую итд вызывала, с течением времени всё пришло 
//к ооп, где объект - главная струкура, которая содержит данные и методы, целостна
// и самодостаточна

let soldier = {
  health: 400,
  armor: 100
};

let john = {
  health: 100
};

john.__proto__ = soldier;

console.log(john); //выводит нам сам объект
console.log(john.armor); //ищет в объекте, тк john - это прототип солдата, 
//выдает нам значение 100, взятое из прототипа






